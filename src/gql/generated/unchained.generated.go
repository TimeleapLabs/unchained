// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/KenshiTech/unchained/src/datasets"
	"github.com/KenshiTech/unchained/src/ent"
	"github.com/KenshiTech/unchained/src/gql/types"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

type AssetPriceResolver interface {
	Price(ctx context.Context, obj *ent.AssetPrice) (uint64, error)
	Signature(ctx context.Context, obj *ent.AssetPrice) (types.Bytes, error)
}
type CorrectnessReportResolver interface {
	Signature(ctx context.Context, obj *ent.CorrectnessReport) (types.Bytes, error)
	Hash(ctx context.Context, obj *ent.CorrectnessReport) (types.Bytes, error)
	Topic(ctx context.Context, obj *ent.CorrectnessReport) (types.Bytes, error)
}
type EventLogResolver interface {
	Signature(ctx context.Context, obj *ent.EventLog) (types.Bytes, error)

	Transaction(ctx context.Context, obj *ent.EventLog) (types.Bytes, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id int) (ent.Noder, error)
	Nodes(ctx context.Context, ids []int) ([]ent.Noder, error)
	AssetPrices(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.AssetPriceOrder, where *ent.AssetPriceWhereInput) (*ent.AssetPriceConnection, error)
	CorrectnessReports(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.CorrectnessReportOrder, where *ent.CorrectnessReportWhereInput) (*ent.CorrectnessReportConnection, error)
	EventLogs(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.EventLogOrder, where *ent.EventLogWhereInput) (*ent.EventLogConnection, error)
	Signers(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.SignerOrder, where *ent.SignerWhereInput) (*ent.SignerConnection, error)
}
type SignerResolver interface {
	Key(ctx context.Context, obj *ent.Signer) (types.Bytes, error)
	Shortkey(ctx context.Context, obj *ent.Signer) (types.Bytes, error)
}

type AssetPriceWhereInputResolver interface {
	Price(ctx context.Context, obj *ent.AssetPriceWhereInput, data *uint64) error
	PriceNeq(ctx context.Context, obj *ent.AssetPriceWhereInput, data *uint64) error
	PriceIn(ctx context.Context, obj *ent.AssetPriceWhereInput, data []uint64) error
	PriceNotIn(ctx context.Context, obj *ent.AssetPriceWhereInput, data []uint64) error
	PriceGt(ctx context.Context, obj *ent.AssetPriceWhereInput, data *uint64) error
	PriceGte(ctx context.Context, obj *ent.AssetPriceWhereInput, data *uint64) error
	PriceLt(ctx context.Context, obj *ent.AssetPriceWhereInput, data *uint64) error
	PriceLte(ctx context.Context, obj *ent.AssetPriceWhereInput, data *uint64) error
}
type CorrectnessReportWhereInputResolver interface {
	Topic(ctx context.Context, obj *ent.CorrectnessReportWhereInput, data *string) error
	Hash(ctx context.Context, obj *ent.CorrectnessReportWhereInput, data *string) error
}
type SignerWhereInputResolver interface {
	Key(ctx context.Context, obj *ent.SignerWhereInput, data *string) error
}

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_assetPrices_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[int]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[int]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.AssetPriceOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOAssetPriceOrder2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.AssetPriceWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOAssetPriceWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_correctnessReports_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[int]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[int]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.CorrectnessReportOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOCorrectnessReportOrder2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.CorrectnessReportWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOCorrectnessReportWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_eventLogs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[int]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[int]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.EventLogOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOEventLogOrder2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.EventLogWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOEventLogWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2ᚕintᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_signers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[int]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[int]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.SignerOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOSignerOrder2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.SignerWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOSignerWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AssetPrice_id(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPrice_block(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Block, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPrice_signerscount(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_signerscount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignersCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint2ᚖuint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_signerscount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPrice_price(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_price(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetPrice().Price(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_price(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPrice_signature(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_signature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetPrice().Signature(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋKenshiTechᚋunchainedᚋgqlᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_signature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPrice_asset(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_asset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Asset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_asset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPrice_chain(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPrice_pair(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_pair(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pair, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_pair(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPrice_signers(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPrice_signers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Signer)
	fc.Result = res
	return ec.marshalNSigner2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPrice_signers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPrice",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Signer_id(ctx, field)
			case "name":
				return ec.fieldContext_Signer_name(ctx, field)
			case "evm":
				return ec.fieldContext_Signer_evm(ctx, field)
			case "key":
				return ec.fieldContext_Signer_key(ctx, field)
			case "shortkey":
				return ec.fieldContext_Signer_shortkey(ctx, field)
			case "points":
				return ec.fieldContext_Signer_points(ctx, field)
			case "assetprice":
				return ec.fieldContext_Signer_assetprice(ctx, field)
			case "eventlogs":
				return ec.fieldContext_Signer_eventlogs(ctx, field)
			case "correctnessreport":
				return ec.fieldContext_Signer_correctnessreport(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Signer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPriceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPriceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPriceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AssetPriceEdge)
	fc.Result = res
	return ec.marshalOAssetPriceEdge2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPriceConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPriceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_AssetPriceEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_AssetPriceEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AssetPriceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPriceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPriceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPriceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[int])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPriceConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPriceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPriceConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPriceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPriceConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPriceConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPriceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPriceEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPriceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPriceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AssetPrice)
	fc.Result = res
	return ec.marshalOAssetPrice2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPrice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPriceEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPriceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AssetPrice_id(ctx, field)
			case "block":
				return ec.fieldContext_AssetPrice_block(ctx, field)
			case "signerscount":
				return ec.fieldContext_AssetPrice_signerscount(ctx, field)
			case "price":
				return ec.fieldContext_AssetPrice_price(ctx, field)
			case "signature":
				return ec.fieldContext_AssetPrice_signature(ctx, field)
			case "asset":
				return ec.fieldContext_AssetPrice_asset(ctx, field)
			case "chain":
				return ec.fieldContext_AssetPrice_chain(ctx, field)
			case "pair":
				return ec.fieldContext_AssetPrice_pair(ctx, field)
			case "signers":
				return ec.fieldContext_AssetPrice_signers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AssetPrice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AssetPriceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.AssetPriceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AssetPriceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[int])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AssetPriceEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AssetPriceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReport_id(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReport_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReport_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReport_signerscount(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReport_signerscount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignersCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReport_signerscount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReport_timestamp(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReport_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReport_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReport_signature(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReport_signature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CorrectnessReport().Signature(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋKenshiTechᚋunchainedᚋgqlᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReport_signature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReport_hash(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReport_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CorrectnessReport().Hash(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋKenshiTechᚋunchainedᚋgqlᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReport_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReport_topic(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReport_topic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CorrectnessReport().Topic(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋKenshiTechᚋunchainedᚋgqlᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReport_topic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReport_correct(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReport_correct(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Correct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReport_correct(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReport_signers(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReport_signers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Signer)
	fc.Result = res
	return ec.marshalNSigner2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReport_signers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Signer_id(ctx, field)
			case "name":
				return ec.fieldContext_Signer_name(ctx, field)
			case "evm":
				return ec.fieldContext_Signer_evm(ctx, field)
			case "key":
				return ec.fieldContext_Signer_key(ctx, field)
			case "shortkey":
				return ec.fieldContext_Signer_shortkey(ctx, field)
			case "points":
				return ec.fieldContext_Signer_points(ctx, field)
			case "assetprice":
				return ec.fieldContext_Signer_assetprice(ctx, field)
			case "eventlogs":
				return ec.fieldContext_Signer_eventlogs(ctx, field)
			case "correctnessreport":
				return ec.fieldContext_Signer_correctnessreport(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Signer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReportConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReportConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReportConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.CorrectnessReportEdge)
	fc.Result = res
	return ec.marshalOCorrectnessReportEdge2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReportConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReportConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_CorrectnessReportEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_CorrectnessReportEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CorrectnessReportEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReportConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReportConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReportConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[int])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReportConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReportConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReportConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReportConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReportConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReportConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReportConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReportEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReportEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReportEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.CorrectnessReport)
	fc.Result = res
	return ec.marshalOCorrectnessReport2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReportEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReportEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CorrectnessReport_id(ctx, field)
			case "signerscount":
				return ec.fieldContext_CorrectnessReport_signerscount(ctx, field)
			case "timestamp":
				return ec.fieldContext_CorrectnessReport_timestamp(ctx, field)
			case "signature":
				return ec.fieldContext_CorrectnessReport_signature(ctx, field)
			case "hash":
				return ec.fieldContext_CorrectnessReport_hash(ctx, field)
			case "topic":
				return ec.fieldContext_CorrectnessReport_topic(ctx, field)
			case "correct":
				return ec.fieldContext_CorrectnessReport_correct(ctx, field)
			case "signers":
				return ec.fieldContext_CorrectnessReport_signers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CorrectnessReport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CorrectnessReportEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.CorrectnessReportEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CorrectnessReportEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[int])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CorrectnessReportEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CorrectnessReportEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_id(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_block(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Block, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_signerscount(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_signerscount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignersCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_signerscount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_signature(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_signature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EventLog().Signature(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋKenshiTechᚋunchainedᚋgqlᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_signature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_address(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_chain(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_index(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_event(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_transaction(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_transaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EventLog().Transaction(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋKenshiTechᚋunchainedᚋgqlᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_transaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_args(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]datasets.EventLogArg)
	fc.Result = res
	return ec.marshalNEventLogArg2ᚕgithubᚗcomᚋKenshiTechᚋunchainedᚋdatasetsᚐEventLogArgᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_EventLogArg_name(ctx, field)
			case "value":
				return ec.fieldContext_EventLogArg_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventLogArg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLog_signers(ctx context.Context, field graphql.CollectedField, obj *ent.EventLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLog_signers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Signer)
	fc.Result = res
	return ec.marshalNSigner2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLog_signers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLog",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Signer_id(ctx, field)
			case "name":
				return ec.fieldContext_Signer_name(ctx, field)
			case "evm":
				return ec.fieldContext_Signer_evm(ctx, field)
			case "key":
				return ec.fieldContext_Signer_key(ctx, field)
			case "shortkey":
				return ec.fieldContext_Signer_shortkey(ctx, field)
			case "points":
				return ec.fieldContext_Signer_points(ctx, field)
			case "assetprice":
				return ec.fieldContext_Signer_assetprice(ctx, field)
			case "eventlogs":
				return ec.fieldContext_Signer_eventlogs(ctx, field)
			case "correctnessreport":
				return ec.fieldContext_Signer_correctnessreport(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Signer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLogConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.EventLogConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLogConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.EventLogEdge)
	fc.Result = res
	return ec.marshalOEventLogEdge2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLogConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLogConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_EventLogEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_EventLogEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventLogEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLogConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.EventLogConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLogConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[int])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLogConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLogConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLogConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.EventLogConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLogConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLogConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLogConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLogEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.EventLogEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLogEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.EventLog)
	fc.Result = res
	return ec.marshalOEventLog2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLog(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLogEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLogEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventLog_id(ctx, field)
			case "block":
				return ec.fieldContext_EventLog_block(ctx, field)
			case "signerscount":
				return ec.fieldContext_EventLog_signerscount(ctx, field)
			case "signature":
				return ec.fieldContext_EventLog_signature(ctx, field)
			case "address":
				return ec.fieldContext_EventLog_address(ctx, field)
			case "chain":
				return ec.fieldContext_EventLog_chain(ctx, field)
			case "index":
				return ec.fieldContext_EventLog_index(ctx, field)
			case "event":
				return ec.fieldContext_EventLog_event(ctx, field)
			case "transaction":
				return ec.fieldContext_EventLog_transaction(ctx, field)
			case "args":
				return ec.fieldContext_EventLog_args(ctx, field)
			case "signers":
				return ec.fieldContext_EventLog_signers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventLog", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EventLogEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.EventLogEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EventLogEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[int])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EventLogEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EventLogEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[int])
	fc.Result = res
	return ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[int])
	fc.Result = res
	return ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubᚗcomᚋKenshiTechᚋunchainedᚋentᚐNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2ᚕgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_assetPrices(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_assetPrices(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AssetPrices(rctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.AssetPriceOrder), fc.Args["where"].(*ent.AssetPriceWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AssetPriceConnection)
	fc.Result = res
	return ec.marshalNAssetPriceConnection2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_assetPrices(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_AssetPriceConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_AssetPriceConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_AssetPriceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AssetPriceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_assetPrices_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_correctnessReports(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_correctnessReports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CorrectnessReports(rctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.CorrectnessReportOrder), fc.Args["where"].(*ent.CorrectnessReportWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.CorrectnessReportConnection)
	fc.Result = res
	return ec.marshalNCorrectnessReportConnection2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_correctnessReports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_CorrectnessReportConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_CorrectnessReportConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_CorrectnessReportConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CorrectnessReportConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_correctnessReports_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_eventLogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_eventLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EventLogs(rctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.EventLogOrder), fc.Args["where"].(*ent.EventLogWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.EventLogConnection)
	fc.Result = res
	return ec.marshalNEventLogConnection2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_eventLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_EventLogConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EventLogConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EventLogConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventLogConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_eventLogs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_signers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_signers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Signers(rctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.SignerOrder), fc.Args["where"].(*ent.SignerWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.SignerConnection)
	fc.Result = res
	return ec.marshalNSignerConnection2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_signers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_SignerConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SignerConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_SignerConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignerConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_signers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_id(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_name(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_evm(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_evm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Evm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_evm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_key(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Signer().Key(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋKenshiTechᚋunchainedᚋgqlᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_shortkey(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_shortkey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Signer().Shortkey(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(types.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋKenshiTechᚋunchainedᚋgqlᚋtypesᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_shortkey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_points(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_points(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Points, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_points(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_assetprice(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_assetprice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetPrice(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AssetPrice)
	fc.Result = res
	return ec.marshalOAssetPrice2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_assetprice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AssetPrice_id(ctx, field)
			case "block":
				return ec.fieldContext_AssetPrice_block(ctx, field)
			case "signerscount":
				return ec.fieldContext_AssetPrice_signerscount(ctx, field)
			case "price":
				return ec.fieldContext_AssetPrice_price(ctx, field)
			case "signature":
				return ec.fieldContext_AssetPrice_signature(ctx, field)
			case "asset":
				return ec.fieldContext_AssetPrice_asset(ctx, field)
			case "chain":
				return ec.fieldContext_AssetPrice_chain(ctx, field)
			case "pair":
				return ec.fieldContext_AssetPrice_pair(ctx, field)
			case "signers":
				return ec.fieldContext_AssetPrice_signers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AssetPrice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_eventlogs(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_eventlogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.EventLog)
	fc.Result = res
	return ec.marshalOEventLog2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_eventlogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EventLog_id(ctx, field)
			case "block":
				return ec.fieldContext_EventLog_block(ctx, field)
			case "signerscount":
				return ec.fieldContext_EventLog_signerscount(ctx, field)
			case "signature":
				return ec.fieldContext_EventLog_signature(ctx, field)
			case "address":
				return ec.fieldContext_EventLog_address(ctx, field)
			case "chain":
				return ec.fieldContext_EventLog_chain(ctx, field)
			case "index":
				return ec.fieldContext_EventLog_index(ctx, field)
			case "event":
				return ec.fieldContext_EventLog_event(ctx, field)
			case "transaction":
				return ec.fieldContext_EventLog_transaction(ctx, field)
			case "args":
				return ec.fieldContext_EventLog_args(ctx, field)
			case "signers":
				return ec.fieldContext_EventLog_signers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EventLog", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Signer_correctnessreport(ctx context.Context, field graphql.CollectedField, obj *ent.Signer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Signer_correctnessreport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CorrectnessReport(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.CorrectnessReport)
	fc.Result = res
	return ec.marshalOCorrectnessReport2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Signer_correctnessreport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Signer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CorrectnessReport_id(ctx, field)
			case "signerscount":
				return ec.fieldContext_CorrectnessReport_signerscount(ctx, field)
			case "timestamp":
				return ec.fieldContext_CorrectnessReport_timestamp(ctx, field)
			case "signature":
				return ec.fieldContext_CorrectnessReport_signature(ctx, field)
			case "hash":
				return ec.fieldContext_CorrectnessReport_hash(ctx, field)
			case "topic":
				return ec.fieldContext_CorrectnessReport_topic(ctx, field)
			case "correct":
				return ec.fieldContext_CorrectnessReport_correct(ctx, field)
			case "signers":
				return ec.fieldContext_CorrectnessReport_signers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CorrectnessReport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignerConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.SignerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignerConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.SignerEdge)
	fc.Result = res
	return ec.marshalOSignerEdge2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignerConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SignerEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_SignerEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignerEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignerConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.SignerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignerConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[int])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignerConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignerConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.SignerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignerConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignerConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignerEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.SignerEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignerEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Signer)
	fc.Result = res
	return ec.marshalOSigner2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSigner(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignerEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Signer_id(ctx, field)
			case "name":
				return ec.fieldContext_Signer_name(ctx, field)
			case "evm":
				return ec.fieldContext_Signer_evm(ctx, field)
			case "key":
				return ec.fieldContext_Signer_key(ctx, field)
			case "shortkey":
				return ec.fieldContext_Signer_shortkey(ctx, field)
			case "points":
				return ec.fieldContext_Signer_points(ctx, field)
			case "assetprice":
				return ec.fieldContext_Signer_assetprice(ctx, field)
			case "eventlogs":
				return ec.fieldContext_Signer_eventlogs(ctx, field)
			case "correctnessreport":
				return ec.fieldContext_Signer_correctnessreport(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Signer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignerEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.SignerEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignerEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[int])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignerEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAssetPriceOrder(ctx context.Context, obj interface{}) (ent.AssetPriceOrder, error) {
	var it ent.AssetPriceOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNAssetPriceOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAssetPriceWhereInput(ctx context.Context, obj interface{}) (ent.AssetPriceWhereInput, error) {
	var it ent.AssetPriceWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "block", "blockNEQ", "blockIn", "blockNotIn", "blockGT", "blockGTE", "blockLT", "blockLTE", "signerscount", "signerscountNEQ", "signerscountIn", "signerscountNotIn", "signerscountGT", "signerscountGTE", "signerscountLT", "signerscountLTE", "signerscountIsNil", "signerscountNotNil", "price", "priceNEQ", "priceIn", "priceNotIn", "priceGT", "priceGTE", "priceLT", "priceLTE", "asset", "assetNEQ", "assetIn", "assetNotIn", "assetGT", "assetGTE", "assetLT", "assetLTE", "assetContains", "assetHasPrefix", "assetHasSuffix", "assetIsNil", "assetNotNil", "assetEqualFold", "assetContainsFold", "chain", "chainNEQ", "chainIn", "chainNotIn", "chainGT", "chainGTE", "chainLT", "chainLTE", "chainContains", "chainHasPrefix", "chainHasSuffix", "chainIsNil", "chainNotNil", "chainEqualFold", "chainContainsFold", "pair", "pairNEQ", "pairIn", "pairNotIn", "pairGT", "pairGTE", "pairLT", "pairLTE", "pairContains", "pairHasPrefix", "pairHasSuffix", "pairIsNil", "pairNotNil", "pairEqualFold", "pairContainsFold", "hasSigners", "hasSignersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOAssetPriceWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOAssetPriceWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOAssetPriceWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "block":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("block"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Block = data
		case "blockNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNEQ"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockNEQ = data
		case "blockIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockIn = data
		case "blockNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNotIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockNotIn = data
		case "blockGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockGT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockGT = data
		case "blockGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockGTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockGTE = data
		case "blockLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockLT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockLT = data
		case "blockLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockLTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockLTE = data
		case "signerscount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscount"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCount = data
		case "signerscountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountNEQ"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountNEQ = data
		case "signerscountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountIn = data
		case "signerscountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountNotIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountNotIn = data
		case "signerscountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountGT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountGT = data
		case "signerscountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountGTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountGTE = data
		case "signerscountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountLT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountLT = data
		case "signerscountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountLTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountLTE = data
		case "signerscountIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountIsNil = data
		case "signerscountNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountNotNil = data
		case "price":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AssetPriceWhereInput().Price(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceNEQ"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AssetPriceWhereInput().PriceNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AssetPriceWhereInput().PriceIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceNotIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AssetPriceWhereInput().PriceNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceGT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AssetPriceWhereInput().PriceGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceGTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AssetPriceWhereInput().PriceGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceLT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AssetPriceWhereInput().PriceLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "priceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priceLTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AssetPriceWhereInput().PriceLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "asset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asset"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Asset = data
		case "assetNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetNEQ = data
		case "assetIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetIn = data
		case "assetNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetNotIn = data
		case "assetGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetGT = data
		case "assetGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetGTE = data
		case "assetLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetLT = data
		case "assetLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetLTE = data
		case "assetContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetContains = data
		case "assetHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetHasPrefix = data
		case "assetHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetHasSuffix = data
		case "assetIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetIsNil = data
		case "assetNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetNotNil = data
		case "assetEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetEqualFold = data
		case "assetContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AssetContainsFold = data
		case "chain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Chain = data
		case "chainNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainNEQ = data
		case "chainIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainIn = data
		case "chainNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainNotIn = data
		case "chainGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainGT = data
		case "chainGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainGTE = data
		case "chainLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainLT = data
		case "chainLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainLTE = data
		case "chainContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainContains = data
		case "chainHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainHasPrefix = data
		case "chainHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainHasSuffix = data
		case "chainIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainIsNil = data
		case "chainNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainNotNil = data
		case "chainEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainEqualFold = data
		case "chainContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainContainsFold = data
		case "pair":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pair"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Pair = data
		case "pairNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairNEQ = data
		case "pairIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairIn = data
		case "pairNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairNotIn = data
		case "pairGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairGT = data
		case "pairGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairGTE = data
		case "pairLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairLT = data
		case "pairLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairLTE = data
		case "pairContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairContains = data
		case "pairHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairHasPrefix = data
		case "pairHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairHasSuffix = data
		case "pairIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairIsNil = data
		case "pairNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairNotNil = data
		case "pairEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairEqualFold = data
		case "pairContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pairContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PairContainsFold = data
		case "hasSigners":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSigners"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSigners = data
		case "hasSignersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSignersWith"))
			data, err := ec.unmarshalOSignerWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSignersWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCorrectnessReportOrder(ctx context.Context, obj interface{}) (ent.CorrectnessReportOrder, error) {
	var it ent.CorrectnessReportOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNCorrectnessReportOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCorrectnessReportWhereInput(ctx context.Context, obj interface{}) (ent.CorrectnessReportWhereInput, error) {
	var it ent.CorrectnessReportWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "signerscount", "signerscountNEQ", "signerscountIn", "signerscountNotIn", "signerscountGT", "signerscountGTE", "signerscountLT", "signerscountLTE", "timestamp", "timestampNEQ", "timestampIn", "timestampNotIn", "timestampGT", "timestampGTE", "timestampLT", "timestampLTE", "correct", "correctNEQ", "hasSigners", "hasSignersWith", "topic", "hash"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCorrectnessReportWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCorrectnessReportWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCorrectnessReportWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "signerscount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscount"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCount = data
		case "signerscountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountNEQ"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountNEQ = data
		case "signerscountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountIn = data
		case "signerscountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountNotIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountNotIn = data
		case "signerscountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountGT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountGT = data
		case "signerscountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountGTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountGTE = data
		case "signerscountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountLT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountLT = data
		case "signerscountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountLTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountLTE = data
		case "timestamp":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestamp"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timestamp = data
		case "timestampNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNEQ"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimestampNEQ = data
		case "timestampIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimestampIn = data
		case "timestampNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampNotIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimestampNotIn = data
		case "timestampGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampGT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimestampGT = data
		case "timestampGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampGTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimestampGTE = data
		case "timestampLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampLT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimestampLT = data
		case "timestampLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timestampLTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimestampLTE = data
		case "correct":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("correct"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Correct = data
		case "correctNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("correctNEQ"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CorrectNEQ = data
		case "hasSigners":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSigners"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSigners = data
		case "hasSignersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSignersWith"))
			data, err := ec.unmarshalOSignerWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSignersWith = data
		case "topic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("topic"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CorrectnessReportWhereInput().Topic(ctx, &it, data); err != nil {
				return it, err
			}
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CorrectnessReportWhereInput().Hash(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventLogOrder(ctx context.Context, obj interface{}) (ent.EventLogOrder, error) {
	var it ent.EventLogOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNEventLogOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventLogWhereInput(ctx context.Context, obj interface{}) (ent.EventLogWhereInput, error) {
	var it ent.EventLogWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "block", "blockNEQ", "blockIn", "blockNotIn", "blockGT", "blockGTE", "blockLT", "blockLTE", "signerscount", "signerscountNEQ", "signerscountIn", "signerscountNotIn", "signerscountGT", "signerscountGTE", "signerscountLT", "signerscountLTE", "address", "addressNEQ", "addressIn", "addressNotIn", "addressGT", "addressGTE", "addressLT", "addressLTE", "addressContains", "addressHasPrefix", "addressHasSuffix", "addressEqualFold", "addressContainsFold", "chain", "chainNEQ", "chainIn", "chainNotIn", "chainGT", "chainGTE", "chainLT", "chainLTE", "chainContains", "chainHasPrefix", "chainHasSuffix", "chainEqualFold", "chainContainsFold", "index", "indexNEQ", "indexIn", "indexNotIn", "indexGT", "indexGTE", "indexLT", "indexLTE", "event", "eventNEQ", "eventIn", "eventNotIn", "eventGT", "eventGTE", "eventLT", "eventLTE", "eventContains", "eventHasPrefix", "eventHasSuffix", "eventEqualFold", "eventContainsFold", "hasSigners", "hasSignersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOEventLogWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOEventLogWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOEventLogWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "block":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("block"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Block = data
		case "blockNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNEQ"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockNEQ = data
		case "blockIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockIn = data
		case "blockNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockNotIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockNotIn = data
		case "blockGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockGT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockGT = data
		case "blockGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockGTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockGTE = data
		case "blockLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockLT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockLT = data
		case "blockLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockLTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockLTE = data
		case "signerscount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscount"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCount = data
		case "signerscountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountNEQ"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountNEQ = data
		case "signerscountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountIn = data
		case "signerscountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountNotIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountNotIn = data
		case "signerscountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountGT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountGT = data
		case "signerscountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountGTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountGTE = data
		case "signerscountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountLT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountLT = data
		case "signerscountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signerscountLTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignersCountLTE = data
		case "address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Address = data
		case "addressNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressNEQ = data
		case "addressIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressIn = data
		case "addressNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressNotIn = data
		case "addressGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressGT = data
		case "addressGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressGTE = data
		case "addressLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressLT = data
		case "addressLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressLTE = data
		case "addressContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressContains = data
		case "addressHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressHasPrefix = data
		case "addressHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressHasSuffix = data
		case "addressEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressEqualFold = data
		case "addressContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddressContainsFold = data
		case "chain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Chain = data
		case "chainNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainNEQ = data
		case "chainIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainIn = data
		case "chainNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainNotIn = data
		case "chainGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainGT = data
		case "chainGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainGTE = data
		case "chainLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainLT = data
		case "chainLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainLTE = data
		case "chainContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainContains = data
		case "chainHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainHasPrefix = data
		case "chainHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainHasSuffix = data
		case "chainEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainEqualFold = data
		case "chainContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainContainsFold = data
		case "index":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("index"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Index = data
		case "indexNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexNEQ"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexNEQ = data
		case "indexIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexIn = data
		case "indexNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexNotIn"))
			data, err := ec.unmarshalOUint2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexNotIn = data
		case "indexGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexGT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexGT = data
		case "indexGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexGTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexGTE = data
		case "indexLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexLT"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexLT = data
		case "indexLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexLTE"))
			data, err := ec.unmarshalOUint2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexLTE = data
		case "event":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("event"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Event = data
		case "eventNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventNEQ = data
		case "eventIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventIn = data
		case "eventNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventNotIn = data
		case "eventGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventGT = data
		case "eventGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventGTE = data
		case "eventLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventLT = data
		case "eventLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventLTE = data
		case "eventContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventContains = data
		case "eventHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventHasPrefix = data
		case "eventHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventHasSuffix = data
		case "eventEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventEqualFold = data
		case "eventContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventContainsFold = data
		case "hasSigners":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSigners"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSigners = data
		case "hasSignersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSignersWith"))
			data, err := ec.unmarshalOSignerWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSignersWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSignerOrder(ctx context.Context, obj interface{}) (ent.SignerOrder, error) {
	var it ent.SignerOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSignerOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSignerWhereInput(ctx context.Context, obj interface{}) (ent.SignerWhereInput, error) {
	var it ent.SignerWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "evm", "evmNEQ", "evmIn", "evmNotIn", "evmGT", "evmGTE", "evmLT", "evmLTE", "evmContains", "evmHasPrefix", "evmHasSuffix", "evmIsNil", "evmNotNil", "evmEqualFold", "evmContainsFold", "points", "pointsNEQ", "pointsIn", "pointsNotIn", "pointsGT", "pointsGTE", "pointsLT", "pointsLTE", "hasAssetPrice", "hasAssetPriceWith", "hasEventLogs", "hasEventLogsWith", "hasCorrectnessReport", "hasCorrectnessReportWith", "key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOSignerWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOSignerWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOSignerWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "evm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evm"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Evm = data
		case "evmNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmNEQ = data
		case "evmIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmIn = data
		case "evmNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmNotIn = data
		case "evmGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmGT = data
		case "evmGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmGTE = data
		case "evmLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmLT = data
		case "evmLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmLTE = data
		case "evmContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmContains = data
		case "evmHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmHasPrefix = data
		case "evmHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmHasSuffix = data
		case "evmIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmIsNil = data
		case "evmNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmNotNil = data
		case "evmEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmEqualFold = data
		case "evmContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("evmContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EvmContainsFold = data
		case "points":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("points"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Points = data
		case "pointsNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointsNEQ"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointsNEQ = data
		case "pointsIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointsIn"))
			data, err := ec.unmarshalOInt2ᚕint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointsIn = data
		case "pointsNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointsNotIn"))
			data, err := ec.unmarshalOInt2ᚕint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointsNotIn = data
		case "pointsGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointsGT"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointsGT = data
		case "pointsGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointsGTE"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointsGTE = data
		case "pointsLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointsLT"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointsLT = data
		case "pointsLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pointsLTE"))
			data, err := ec.unmarshalOInt2ᚖint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PointsLTE = data
		case "hasAssetPrice":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAssetPrice"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAssetPrice = data
		case "hasAssetPriceWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAssetPriceWith"))
			data, err := ec.unmarshalOAssetPriceWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAssetPriceWith = data
		case "hasEventLogs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEventLogs"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEventLogs = data
		case "hasEventLogsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEventLogsWith"))
			data, err := ec.unmarshalOEventLogWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEventLogsWith = data
		case "hasCorrectnessReport":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCorrectnessReport"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCorrectnessReport = data
		case "hasCorrectnessReportWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCorrectnessReportWith"))
			data, err := ec.unmarshalOCorrectnessReportWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCorrectnessReportWith = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.SignerWhereInput().Key(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.AssetPrice:
		if obj == nil {
			return graphql.Null
		}
		return ec._AssetPrice(ctx, sel, obj)
	case *ent.CorrectnessReport:
		if obj == nil {
			return graphql.Null
		}
		return ec._CorrectnessReport(ctx, sel, obj)
	case *ent.EventLog:
		if obj == nil {
			return graphql.Null
		}
		return ec._EventLog(ctx, sel, obj)
	case *ent.Signer:
		if obj == nil {
			return graphql.Null
		}
		return ec._Signer(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var assetPriceImplementors = []string{"AssetPrice", "Node"}

func (ec *executionContext) _AssetPrice(ctx context.Context, sel ast.SelectionSet, obj *ent.AssetPrice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetPriceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetPrice")
		case "id":
			out.Values[i] = ec._AssetPrice_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "block":
			out.Values[i] = ec._AssetPrice_block(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "signerscount":
			out.Values[i] = ec._AssetPrice_signerscount(ctx, field, obj)
		case "price":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetPrice_price(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "signature":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetPrice_signature(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "asset":
			out.Values[i] = ec._AssetPrice_asset(ctx, field, obj)
		case "chain":
			out.Values[i] = ec._AssetPrice_chain(ctx, field, obj)
		case "pair":
			out.Values[i] = ec._AssetPrice_pair(ctx, field, obj)
		case "signers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetPrice_signers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var assetPriceConnectionImplementors = []string{"AssetPriceConnection"}

func (ec *executionContext) _AssetPriceConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.AssetPriceConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetPriceConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetPriceConnection")
		case "edges":
			out.Values[i] = ec._AssetPriceConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._AssetPriceConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._AssetPriceConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var assetPriceEdgeImplementors = []string{"AssetPriceEdge"}

func (ec *executionContext) _AssetPriceEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.AssetPriceEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetPriceEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetPriceEdge")
		case "node":
			out.Values[i] = ec._AssetPriceEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._AssetPriceEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var correctnessReportImplementors = []string{"CorrectnessReport", "Node"}

func (ec *executionContext) _CorrectnessReport(ctx context.Context, sel ast.SelectionSet, obj *ent.CorrectnessReport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, correctnessReportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CorrectnessReport")
		case "id":
			out.Values[i] = ec._CorrectnessReport_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "signerscount":
			out.Values[i] = ec._CorrectnessReport_signerscount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "timestamp":
			out.Values[i] = ec._CorrectnessReport_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "signature":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CorrectnessReport_signature(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hash":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CorrectnessReport_hash(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "topic":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CorrectnessReport_topic(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "correct":
			out.Values[i] = ec._CorrectnessReport_correct(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "signers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CorrectnessReport_signers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var correctnessReportConnectionImplementors = []string{"CorrectnessReportConnection"}

func (ec *executionContext) _CorrectnessReportConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.CorrectnessReportConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, correctnessReportConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CorrectnessReportConnection")
		case "edges":
			out.Values[i] = ec._CorrectnessReportConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._CorrectnessReportConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._CorrectnessReportConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var correctnessReportEdgeImplementors = []string{"CorrectnessReportEdge"}

func (ec *executionContext) _CorrectnessReportEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.CorrectnessReportEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, correctnessReportEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CorrectnessReportEdge")
		case "node":
			out.Values[i] = ec._CorrectnessReportEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._CorrectnessReportEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventLogImplementors = []string{"EventLog", "Node"}

func (ec *executionContext) _EventLog(ctx context.Context, sel ast.SelectionSet, obj *ent.EventLog) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventLogImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventLog")
		case "id":
			out.Values[i] = ec._EventLog_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "block":
			out.Values[i] = ec._EventLog_block(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "signerscount":
			out.Values[i] = ec._EventLog_signerscount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "signature":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventLog_signature(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "address":
			out.Values[i] = ec._EventLog_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "chain":
			out.Values[i] = ec._EventLog_chain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "index":
			out.Values[i] = ec._EventLog_index(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "event":
			out.Values[i] = ec._EventLog_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "transaction":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventLog_transaction(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "args":
			out.Values[i] = ec._EventLog_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "signers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EventLog_signers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventLogConnectionImplementors = []string{"EventLogConnection"}

func (ec *executionContext) _EventLogConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.EventLogConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventLogConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventLogConnection")
		case "edges":
			out.Values[i] = ec._EventLogConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._EventLogConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._EventLogConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventLogEdgeImplementors = []string{"EventLogEdge"}

func (ec *executionContext) _EventLogEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.EventLogEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventLogEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EventLogEdge")
		case "node":
			out.Values[i] = ec._EventLogEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._EventLogEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[int]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "assetPrices":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_assetPrices(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "correctnessReports":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_correctnessReports(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "eventLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_eventLogs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "signers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_signers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var signerImplementors = []string{"Signer", "Node"}

func (ec *executionContext) _Signer(ctx context.Context, sel ast.SelectionSet, obj *ent.Signer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Signer")
		case "id":
			out.Values[i] = ec._Signer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Signer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "evm":
			out.Values[i] = ec._Signer_evm(ctx, field, obj)
		case "key":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Signer_key(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "shortkey":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Signer_shortkey(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "points":
			out.Values[i] = ec._Signer_points(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "assetprice":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Signer_assetprice(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventlogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Signer_eventlogs(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "correctnessreport":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Signer_correctnessreport(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var signerConnectionImplementors = []string{"SignerConnection"}

func (ec *executionContext) _SignerConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.SignerConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signerConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignerConnection")
		case "edges":
			out.Values[i] = ec._SignerConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._SignerConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._SignerConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var signerEdgeImplementors = []string{"SignerEdge"}

func (ec *executionContext) _SignerEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.SignerEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signerEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignerEdge")
		case "node":
			out.Values[i] = ec._SignerEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._SignerEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAssetPrice2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPrice(ctx context.Context, sel ast.SelectionSet, v *ent.AssetPrice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AssetPrice(ctx, sel, v)
}

func (ec *executionContext) marshalNAssetPriceConnection2githubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceConnection(ctx context.Context, sel ast.SelectionSet, v ent.AssetPriceConnection) graphql.Marshaler {
	return ec._AssetPriceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNAssetPriceConnection2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceConnection(ctx context.Context, sel ast.SelectionSet, v *ent.AssetPriceConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AssetPriceConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAssetPriceOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceOrderField(ctx context.Context, v interface{}) (*ent.AssetPriceOrderField, error) {
	var res = new(ent.AssetPriceOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAssetPriceOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.AssetPriceOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNAssetPriceWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInput(ctx context.Context, v interface{}) (*ent.AssetPriceWhereInput, error) {
	res, err := ec.unmarshalInputAssetPriceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCorrectnessReport2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReport(ctx context.Context, sel ast.SelectionSet, v *ent.CorrectnessReport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CorrectnessReport(ctx, sel, v)
}

func (ec *executionContext) marshalNCorrectnessReportConnection2githubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportConnection(ctx context.Context, sel ast.SelectionSet, v ent.CorrectnessReportConnection) graphql.Marshaler {
	return ec._CorrectnessReportConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCorrectnessReportConnection2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportConnection(ctx context.Context, sel ast.SelectionSet, v *ent.CorrectnessReportConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CorrectnessReportConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCorrectnessReportOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportOrderField(ctx context.Context, v interface{}) (*ent.CorrectnessReportOrderField, error) {
	var res = new(ent.CorrectnessReportOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCorrectnessReportOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.CorrectnessReportOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNCorrectnessReportWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInput(ctx context.Context, v interface{}) (*ent.CorrectnessReportWhereInput, error) {
	res, err := ec.unmarshalInputCorrectnessReportWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v interface{}) (entgql.Cursor[int], error) {
	var res entgql.Cursor[int]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[int]) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEventLog2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLog(ctx context.Context, sel ast.SelectionSet, v *ent.EventLog) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventLog(ctx, sel, v)
}

func (ec *executionContext) marshalNEventLogConnection2githubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogConnection(ctx context.Context, sel ast.SelectionSet, v ent.EventLogConnection) graphql.Marshaler {
	return ec._EventLogConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNEventLogConnection2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogConnection(ctx context.Context, sel ast.SelectionSet, v *ent.EventLogConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EventLogConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventLogOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogOrderField(ctx context.Context, v interface{}) (*ent.EventLogOrderField, error) {
	var res = new(ent.EventLogOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventLogOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.EventLogOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNEventLogWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInput(ctx context.Context, v interface{}) (*ent.EventLogWhereInput, error) {
	res, err := ec.unmarshalInputEventLogWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2ᚕgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubᚗcomᚋKenshiTechᚋunchainedᚋentᚐNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, v interface{}) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[int]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNSigner2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Signer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSigner2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSigner(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSigner2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSigner(ctx context.Context, sel ast.SelectionSet, v *ent.Signer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Signer(ctx, sel, v)
}

func (ec *executionContext) marshalNSignerConnection2githubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerConnection(ctx context.Context, sel ast.SelectionSet, v ent.SignerConnection) graphql.Marshaler {
	return ec._SignerConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSignerConnection2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerConnection(ctx context.Context, sel ast.SelectionSet, v *ent.SignerConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SignerConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSignerOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerOrderField(ctx context.Context, v interface{}) (*ent.SignerOrderField, error) {
	var res = new(ent.SignerOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSignerOrderField2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.SignerOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNSignerWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInput(ctx context.Context, v interface{}) (*ent.SignerWhereInput, error) {
	res, err := ec.unmarshalInputSignerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUint2uint64(ctx context.Context, v interface{}) (uint64, error) {
	res, err := graphql.UnmarshalUint64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint2uint64(ctx context.Context, sel ast.SelectionSet, v uint64) graphql.Marshaler {
	res := graphql.MarshalUint64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAssetPrice2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.AssetPrice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAssetPrice2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPrice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAssetPrice2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPrice(ctx context.Context, sel ast.SelectionSet, v *ent.AssetPrice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AssetPrice(ctx, sel, v)
}

func (ec *executionContext) marshalOAssetPriceEdge2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.AssetPriceEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAssetPriceEdge2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAssetPriceEdge2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceEdge(ctx context.Context, sel ast.SelectionSet, v *ent.AssetPriceEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AssetPriceEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAssetPriceOrder2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceOrder(ctx context.Context, v interface{}) (*ent.AssetPriceOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAssetPriceOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAssetPriceWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.AssetPriceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AssetPriceWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAssetPriceWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAssetPriceWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐAssetPriceWhereInput(ctx context.Context, v interface{}) (*ent.AssetPriceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAssetPriceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCorrectnessReport2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.CorrectnessReport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCorrectnessReport2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCorrectnessReport2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReport(ctx context.Context, sel ast.SelectionSet, v *ent.CorrectnessReport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CorrectnessReport(ctx, sel, v)
}

func (ec *executionContext) marshalOCorrectnessReportEdge2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.CorrectnessReportEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCorrectnessReportEdge2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCorrectnessReportEdge2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportEdge(ctx context.Context, sel ast.SelectionSet, v *ent.CorrectnessReportEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CorrectnessReportEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCorrectnessReportOrder2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportOrder(ctx context.Context, v interface{}) (*ent.CorrectnessReportOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCorrectnessReportOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCorrectnessReportWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.CorrectnessReportWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.CorrectnessReportWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCorrectnessReportWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCorrectnessReportWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐCorrectnessReportWhereInput(ctx context.Context, v interface{}) (*ent.CorrectnessReportWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCorrectnessReportWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v interface{}) (*entgql.Cursor[int], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[int])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[int]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOEventLog2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.EventLog) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventLog2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOEventLog2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLog(ctx context.Context, sel ast.SelectionSet, v *ent.EventLog) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventLog(ctx, sel, v)
}

func (ec *executionContext) marshalOEventLogEdge2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.EventLogEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEventLogEdge2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOEventLogEdge2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogEdge(ctx context.Context, sel ast.SelectionSet, v *ent.EventLogEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EventLogEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventLogOrder2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogOrder(ctx context.Context, v interface{}) (*ent.EventLogOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventLogOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEventLogWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.EventLogWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.EventLogWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventLogWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEventLogWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐEventLogWhereInput(ctx context.Context, v interface{}) (*ent.EventLogWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventLogWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2githubᚗcomᚋKenshiTechᚋunchainedᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOSigner2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSigner(ctx context.Context, sel ast.SelectionSet, v *ent.Signer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Signer(ctx, sel, v)
}

func (ec *executionContext) marshalOSignerEdge2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.SignerEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSignerEdge2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSignerEdge2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerEdge(ctx context.Context, sel ast.SelectionSet, v *ent.SignerEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SignerEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSignerOrder2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerOrder(ctx context.Context, v interface{}) (*ent.SignerOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSignerOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSignerWhereInput2ᚕᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.SignerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SignerWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSignerWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSignerWhereInput2ᚖgithubᚗcomᚋKenshiTechᚋunchainedᚋentᚐSignerWhereInput(ctx context.Context, v interface{}) (*ent.SignerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSignerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUint2ᚕuint64ᚄ(ctx context.Context, v interface{}) ([]uint64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]uint64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUint2uint64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUint2ᚕuint64ᚄ(ctx context.Context, sel ast.SelectionSet, v []uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUint2uint64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUint2ᚖuint64(ctx context.Context, v interface{}) (*uint64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint2ᚖuint64(ctx context.Context, sel ast.SelectionSet, v *uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUint64(*v)
	return res
}

// endregion ***************************** type.gotpl *****************************
